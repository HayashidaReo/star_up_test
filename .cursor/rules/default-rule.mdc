---
alwaysApply: true
---
# Star Up Test - コーディングルール

## 🎯 プロジェクトの設計思想
このプロジェクトは以下の3つの原則に基づいて設計されています：
- **シンプルさと表現力**: 少ない記述量で直感的に扱えるコード
- **型安全性の徹底**: 実行時エラーを未然に防ぐ型システム
- **開発者体験と所有権**: UIコードをプロジェクト自身が所有し、自由にカスタマイズ

## 🏗️ アーキテクチャ設計ルール

### 1. コンポーネントの責務分離
- 各コンポーネントは1つの明確な責務のみを持つ
- 2つ以上の責務が発生した場合、カスタムフックや別コンポーネントへの切り出しを検討
- 例：計算ロジックとUI表示は分離する

### 2. ディレクトリ構造の厳守
```
src/
├── app/          # ルーティングとページ（Next.js App Router）
├── components/   # 再利用可能な共通コンポーネント
│   ├── ui/      # Shadcn/uiベースのUIコンポーネント
│   └── logic/   # ロジックを含むコンポーネント
├── lib/          # 共通の関数やユーティリティ（純粋関数）
├── store/        # Zustandのストア定義
└── types/        # 型定義とZodスキーマ
```

### 3. 状態管理の原則
- ローカル状態はuseState、グローバル状態はZustandを使用
- ストアは`src/store/`ディレクトリに配置
- ストア名は用途を明確に示す（例：`useExpenseStore`）

## 🔒 型安全性ルール

### 4. 型定義の一元管理
- すべてのデータ構造は`src/types/`で一元管理
- ZodスキーマとTypeScriptの型定義を連携
- `any`型の使用は禁止（技術的負債とみなす）

### 5. Zodスキーマの活用
- フォームバリデーションには必ずZodを使用
- 実行時型チェックとTypeScriptの型推論を連携
- スキーマ名は`ExpenseSchema`のような命名規則に従う

## 🎨 UI/UX設計ルール

### 6. Shadcn/uiの活用
- UIコンポーネントはShadcn/uiベースで構築
- カスタマイズは`src/components/ui/`で行い、プロジェクト独自のデザインシステムを構築
- ブラックボックス化したライブラリへの依存を避ける

### 7. Tailwind CSSの使用原則
- ユーティリティファーストのアプローチ
- カスタムCSSは最小限に抑える
- レスポンシブデザインを前提とした設計

## 📝 コーディングスタイル

### 8. 関数とコンポーネントの命名
- コンポーネント: PascalCase（例：`ExpenseCalculator`）
- 関数: camelCase（例：`calculateSplit`）
- 定数: UPPER_SNAKE_CASE（例：`MAX_EXPENSE_AMOUNT`）

### 9. コメントとドキュメント
- 複雑なロジックには必ずコメントを記載
- 関数の目的、引数、戻り値を明確に記述
- TODOコメントは`// TODO: `の形式で統一

### 10. エラーハンドリング
- エラーメッセージは日本語で分かりやすく
- ユーザーに適切なフィードバックを提供
- 開発時のデバッグ情報も適切に記録

## 🧪 テストと品質保証

### 11. テストの原則
- ビジネスロジックは必ずテストを作成
- コンポーネントのテストはReact Testing Libraryを使用
- StorybookでUIコンポーネントのバリエーションを管理

### 12. コードレビュー
- 型安全性の確認を最優先
- 責務の分離が適切かチェック
- パフォーマンスへの影響を考慮

## 🚀 パフォーマンスと最適化

### 13. Next.js App Routerの活用
- 適切なページ分割とルーティング
- 画像最適化（next/image）の活用
- サーバーコンポーネントとクライアントコンポーネントの使い分け

### 14. 状態管理の最適化
- Zustandのセレクターを活用した不要な再レンダリングの防止
- 大きな状態オブジェクトの分割
- メモ化（useMemo, useCallback）の適切な使用

## 🔄 開発フロー

### 15. ブランチ戦略
- `main` → `develop` → `feature/*`の流れを厳守
- `develop`ブランチへのマージにはPRとCIチェックが必須
- コミットメッセージは明確で具体的に

### 16. 依存関係の管理
- 新しいパッケージの追加は慎重に検討
- 既存の技術スタックで解決できないか確認
- セキュリティアップデートは定期的に実施

## 📚 学習と改善

### 17. コードの継続的改善
- 定期的なリファクタリングの実施
- 技術的負債の早期発見と対処
- チーム内での知識共有とベストプラクティスの共有

### 18. ドキュメントの更新
- 設計思想やアーキテクチャの変更は必ずドキュメントに反映
- 新しく学んだ知見は適切に記録
- 初心者にも分かりやすい説明を心がける

---

## ⚠️ 重要な注意事項
- これらのルールは「なぜ？」という問いに答え、トレードオフを意識した教育的な解説を含んでいます
- アカデミックで理想論的なルールよりも、このプロジェクトの文脈における実用的で長期的な保守性を最優先してください
- ルールに従うことで、自律的に高品質なコードを生み出せるようになることが目標です 